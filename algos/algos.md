### 1. **Sorting Algorithms**
   - **Bubble Sort**: Simple but inefficient for large datasets.
   - **Selection Sort**: Sorts by repeatedly finding the minimum.
   - **Insertion Sort**: Builds the sorted array one element at a time.
   - **Merge Sort**: A divide-and-conquer algorithm that divides the array and then merges sorted halves.
   - **Quick Sort**: Another divide-and-conquer algorithm with faster average performance.
   - **Heap Sort**: Uses a binary heap structure.

### 2. **Searching Algorithms**
   - **Linear Search**: Scans each element in the array.
   - **Binary Search**: Efficient search for sorted arrays.
   - **Depth-First Search (DFS)**: Explores all nodes of a graph or tree.
   - **Breadth-First Search (BFS)**: Explores level by level in a graph or tree.

### 3. **Dynamic Programming**
   - **Fibonacci Sequence**: Classic example to understand memoization.
   - **Longest Common Subsequence**: Finding the longest subsequence that two sequences have in common.
   - **0/1 Knapsack**: Optimizing the best set of items to fit in a bag of limited capacity.

### 4. **Greedy Algorithms**
   - **Dijkstra’s Algorithm**: Finds the shortest path in a graph with non-negative weights.
   - **Prim’s Algorithm**: For finding the minimum spanning tree.
   - **Huffman Encoding**: Lossless data compression.

### 5. **Divide and Conquer**
   - **Merge Sort**: Already mentioned, but a great example of divide-and-conquer.
   - **Quick Sort**: Also applies this technique.
   - **Binary Search**: Breaks down the problem into halves.

### 6. **Backtracking Algorithms**
   - **N-Queens Problem**: Placing N queens on a chessboard.
   - **Sudoku Solver**: Solving the Sudoku puzzle by trial and error.
   - **Permutations and Combinations**: Generating all permutations or combinations of a given set.

### 7. **Graph Algorithms**
   - **Kruskal’s Algorithm**: Another algorithm for minimum spanning trees.
   - **Bellman-Ford Algorithm**: Shortest path algorithm that works with negative weights.
   - **Topological Sorting**: Ordering nodes in a directed graph.

### 8. **String Algorithms**
   - **KMP Algorithm**: For pattern matching in a string.
   - **Rabin-Karp Algorithm**: Another pattern matching technique using hashing.
   - **Trie Data Structure**: Used for storing a dynamic set or associative array.

### 9. **Mathematical Algorithms**
   - **Euclid’s Algorithm**: For finding the greatest common divisor (GCD).
   - **Sieve of Eratosthenes**: For finding all prime numbers up to a certain number.
   - **Fast Exponentiation**: Efficient algorithm for exponentiation in logarithmic time.

### 10. **Data Structures for Efficiency**
   - **Heap**: For efficient priority queue operations.
   - **Binary Search Tree (BST)**: Used for maintaining a sorted set of data.
   - **Hash Maps**: For fast lookups, inserts, and deletions.

These cover a wide range of problems and help build a strong foundation for solving complex tasks.